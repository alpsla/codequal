/**
 * Report Generator V7 - Strict Template Compliance
 * 
 * IMPORTANT: This is the ONLY approved template. 
 * Do NOT import or reference any other templates.
 * 
 * Strict V7 Template Requirements:
 * - Must follow exact section order from critical-pr-report.md
 * - All code snippets must be actual executable code
 * - Repository issues section before PR issues
 * - No references to other template versions
 */

import { ComparisonResult, Issue } from '../types/analysis-types';

export class ReportGeneratorV7Complete {
  // Scoring values remain at 5/3/1/0.5 as requested
  private readonly SCORING_VALUES = {
    critical: 5,
    high: 3,
    medium: 1,
    low: 0.5
  };

  // Unfixed penalties same as new issues as requested
  private readonly UNFIXED_PENALTIES = {
    critical: 5,
    high: 3,
    medium: 1,
    low: 0.5
  };

  generateReport(comparison: ComparisonResult): string {
    const { aiAnalysis } = comparison;
    const score = this.calculateOverallScore(comparison);
    const decision = this.makeDecision(comparison);
    
    let report = '';
    
    // Header
    report += this.generateHeader(comparison);
    report += '\n---\n\n';
    
    // Decision
    report += `## PR Decision: ${decision.decision}\n\n`;
    report += `**Confidence:** ${decision.confidence}%\n\n`;
    report += `${decision.reason}\n`;
    report += '\n---\n\n';
    
    // Executive Summary
    report += this.generateExecutiveSummary(comparison, score);
    report += '\n---\n\n';
    
    // Breaking Changes Section (if any)
    const breakingChangesSection = this.generateBreakingChangesSection(comparison);
    if (breakingChangesSection) {
      report += breakingChangesSection;
      report += '\n---\n\n';
    }
    
    // Category Analysis (1-5)
    report += this.generateSecurityAnalysis(comparison);
    report += this.generatePerformanceAnalysis(comparison);
    report += this.generateCodeQualityAnalysis(comparison);
    report += this.generateArchitectureAnalysis(comparison);
    report += this.generateDependenciesAnalysis(comparison);
    
    // Issues Sections (6-7)
    report += this.generatePRIssuesSection(comparison);
    report += this.generateRepositoryIssuesSection(comparison);
    
    // Additional Sections (8-11)
    report += this.generateEducationalInsights(comparison);
    report += this.generateSkillsTracking(comparison);
    report += this.generateBusinessImpact(comparison);
    report += this.generateActionItems(comparison);
    
    // Conclusion
    report += this.generateConclusion(comparison, decision);
    
    // Score Summary
    report += this.generateScoreSummary(comparison);
    
    // Footer
    report += '\n---\n\n';
    report += '*Generated by CodeQual AI Analysis Platform v4.0*  \n';
    
    // Add enhanced analysis note if diff analysis was used
    if (comparison.diffAnalysis?.usedDiffAnalysis) {
      report += '*Enhanced with DiffAnalyzer for breaking change detection*  \n';
    }
    
    report += '*For questions or support: support@codequal.com*\n';
    
    return report;
  }

  private generateHeader(comparison: ComparisonResult): string {
    const { aiAnalysis } = comparison;
    
    // Extract username from repository URL dynamically
    const username = this.extractUsernameFromRepo(aiAnalysis.repository || comparison.repository);
    const authorUsername = aiAnalysis.author?.username || username || 'unknown';
    const authorName = aiAnalysis.author?.name || this.formatUsername(authorUsername);
    
    let header = `# Pull Request Analysis Report

**Repository:** ${aiAnalysis.repository || comparison.repository || 'Unknown'}  
**PR:** #${aiAnalysis.prNumber || comparison.prNumber || 'N/A'} - ${aiAnalysis.prTitle || 'Code Changes'}  
**Author:** ${authorName} (@${authorUsername})  
**Analysis Date:** ${new Date().toISOString()}  
<<<<<<< HEAD
**Model Used:** ${aiAnalysis.modelUsed || 'GPT-4'} (Dynamically Selected)  
**Scan Duration:** ${aiAnalysis.scanDuration || comparison.scanDuration || '0.0'} seconds`;
=======
**Model Used:** ${aiAnalysis?.modelUsed || 'GPT-4'}`;
    
    // Add diff analysis indicator if present
    if (comparison.diffAnalysis?.usedDiffAnalysis) {
      header += ` (Enhanced with DiffAnalyzer)`;
    } else {
      header += ` (Dynamically Selected)`;
    }
    
    header += `  
**Scan Duration:** ${aiAnalysis?.scanDuration || comparison.analysis?.scanDuration || '0.0'} seconds`;
    
    // Add breaking changes count if present
    if (comparison.breakingChanges && comparison.breakingChanges.length > 0) {
      header += `  
**Breaking Changes Detected:** ${comparison.breakingChanges.length} 🚨`;
    }
    
    return header;
>>>>>>> 0fb7923 (feat: Integrate DiffAnalyzer breaking changes into V7 report template)
  }
  
  private extractUsernameFromRepo(repoUrl?: string): string {
    if (!repoUrl) return 'unknown';
    
    // Handle GitHub URLs: https://github.com/username/repo
    const githubMatch = repoUrl.match(/github\.com\/([^/]+)\//);
    if (githubMatch) return githubMatch[1];
    
    // Handle GitLab URLs: https://gitlab.com/username/repo or https://gitlab.com/group/subgroup/repo
    const gitlabMatch = repoUrl.match(/gitlab\.com\/([^/]+)\//);
    if (gitlabMatch) return gitlabMatch[1];
    
    // Handle Bitbucket URLs: https://bitbucket.org/username/repo
    const bitbucketMatch = repoUrl.match(/bitbucket\.org\/([^/]+)\//);
    if (bitbucketMatch) return bitbucketMatch[1];
    
    // Handle Azure DevOps URLs: https://dev.azure.com/org/project/_git/repo
    const azureMatch = repoUrl.match(/dev\.azure\.com\/([^/]+)\//);
    if (azureMatch) return azureMatch[1];
    
    return 'unknown';
  }
  
  private formatUsername(username: string): string {
    // Convert username to formatted name (e.g., john-doe -> John Doe)
    return username
      .split(/[-_]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ');
  }

  private generateExecutiveSummary(comparison: ComparisonResult, score: number): string {
    const grade = this.getGrade(score);
    const newIssues = comparison.comparison?.newIssues || [];
    const unfixedIssues = comparison.comparison?.unchangedIssues || [];
    const fixedIssues = comparison.comparison?.fixedIssues || [];
    
    const criticalNew = newIssues.filter(i => i.severity === 'critical').length;
    const highNew = newIssues.filter(i => i.severity === 'high').length;
    const criticalUnfixed = unfixedIssues.filter(i => i.severity === 'critical').length;
    const highUnfixed = unfixedIssues.filter(i => i.severity === 'high').length;
    
    let summary = `## Executive Summary\n\n`;
    summary += `**Overall Score: ${score}/100 (Grade: ${grade})**\n\n`;
    summary += `This PR (${comparison.filesChanged || 0} files, ${comparison.linesChanged || 0} lines) `;
    summary += `introduces ${criticalNew} critical and ${highNew} high severity issues`;
    
    if (criticalNew > 0 || highNew > 0) {
      summary += ' that must be resolved before merge';
    }
    summary += `. Additionally, ${unfixedIssues.length} pre-existing issues remain unaddressed.\n\n`;
    
    summary += `### Key Metrics\n`;
    summary += `- **Critical Issues Resolved:** ${fixedIssues.filter(i => i.severity === 'critical').length} ✅\n`;
    summary += `- **New Critical/High Issues:** ${criticalNew + highNew} (${criticalNew} critical, ${highNew} high)`;
    if (criticalNew > 0 || highNew > 0) summary += ' 🚨 **[BLOCKING]**';
    summary += '\n';
<<<<<<< HEAD
    summary += `- **Pre-existing Issues:** ${unfixedIssues.length} (${criticalUnfixed} critical, ${highUnfixed} high) ⚠️ **[Not blocking, but impacts scores]**\n`;
=======
    
    // Add breaking changes to key metrics
    const breakingChanges = comparison.breakingChanges || [];
    if (breakingChanges.length > 0) {
      const criticalBreaking = breakingChanges.filter(c => c.severity === 'critical').length;
      summary += `- **Breaking Changes:** ${breakingChanges.length} total 🚨`;
      if (criticalBreaking > 0) {
        summary += ` **[BLOCKING]**`;
      }
      summary += '\n';
    }
    
    summary += `- **Pre-existing Issues:** ${unfixedIssues.length} total ⚠️ **[Not blocking, but impacts scores]**\n`;
>>>>>>> 0fb7923 (feat: Integrate DiffAnalyzer breaking changes into V7 report template)
    summary += `- **Overall Score Impact:** ${comparison.scoreImpact || 0} points\n`;
    summary += `- **Risk Level:** ${this.getRiskLevel(comparison)}\n`;
    summary += `- **Estimated Review Time:** ${this.estimateReviewTime(comparison)} minutes\n`;
    summary += `- **Files Changed:** ${comparison.filesChanged || 0}\n`;
    summary += `- **Lines Added/Removed:** +${comparison.linesAdded || 0} / -${comparison.linesRemoved || 0}\n\n`;
    
    summary += this.generateIssueDistribution(comparison);
    
    return summary;
  }

  private generateBreakingChangesSection(comparison: ComparisonResult): string {
    const breakingChanges = comparison.breakingChanges || [];
    
    if (breakingChanges.length === 0) {
      return ''; // No section if no breaking changes
    }

    let section = `## 🚨 Breaking Changes Analysis\n\n`;
    section += `### Critical Breaking Changes Detected: ${breakingChanges.length}\n\n`;
    
    breakingChanges.forEach((change, index) => {
      section += `#### ${index + 1}. ${change.type.toUpperCase()}: \`${change.component}\`\n`;
      section += `**Severity:** ${change.severity.toUpperCase()}  \n`;
      if (change.file) {
        section += `**File:** \`${change.file}\`  \n`;
      }
      section += `**Impact:** ${change.description}  \n\n`;
      
      // Show before/after code if available
      if (change.before) {
        section += `**Before:**\n`;
        section += `\`\`\`${this.getLanguageFromFile(change.file || '')}
${change.before}
\`\`\`

`;
      }
      
      if (change.after) {
        section += `**After:**\n`;
        section += `\`\`\`${this.getLanguageFromFile(change.file || '')}
${change.after}
\`\`\`

`;
      }
      
      // Show migration path if available
      if (change.migrationPath) {
        section += `**Required Migration:**\n`;
        section += `\`\`\`${this.getLanguageFromFile(change.file || '')}
${change.migrationPath}
\`\`\`

`;
      }
      
      // Show affected files
      if (change.affectedFiles && change.affectedFiles.length > 0) {
        section += `**Affected Files:**\n`;
        change.affectedFiles.slice(0, 5).forEach(file => {
          section += `- \`${file}\`\n`;
        });
        if (change.affectedFiles.length > 5) {
          section += `- ... and ${change.affectedFiles.length - 5} more\n`;
        }
        section += '\n';
      }
      
      section += '---\n\n';
    });
    
    // Add risk assessment
    section += `### Breaking Changes Risk Assessment\n\n`;
    section += `| Aspect | Impact | Risk Level |\n`;
    section += `|--------|--------|------------|\n`;
    
    const criticalCount = breakingChanges.filter(c => c.severity === 'critical').length;
    const highCount = breakingChanges.filter(c => c.severity === 'high').length;
    const totalAffected = new Set(breakingChanges.flatMap(c => c.affectedFiles || [])).size;
    
    section += `| **Direct Callers** | ${breakingChanges.length} functions | ${criticalCount > 0 ? 'CRITICAL' : highCount > 0 ? 'HIGH' : 'MEDIUM'} |\n`;
    section += `| **Configuration Changes** | ${breakingChanges.filter(c => c.type === 'config_change').length} | ${breakingChanges.some(c => c.type === 'config_change') ? 'HIGH' : 'LOW'} |\n`;
    section += `| **Test Suites** | May require updates | MEDIUM |\n`;
    section += `| **External Dependencies** | Unknown count | HIGH |\n`;
    section += `| **Migration Complexity** | ${criticalCount > 0 ? 'High' : 'Moderate'} | ${criticalCount > 0 ? 'HIGH' : 'MEDIUM'} |\n\n`;
    
    return section;
  }

  private generateSecurityAnalysis(comparison: ComparisonResult): string {
    const categoryScore = comparison.categoryScores?.security || 75;
    const grade = this.getGrade(categoryScore);
    
    let section = `## 1. Security Analysis\n\n`;
    section += `### Score: ${categoryScore}/100 (Grade: ${grade})\n\n`;
    
    // Score breakdown with detailed metrics
    section += `**Score Breakdown:**\n`;
    section += `- Vulnerability Prevention: 75/100 (New critical vulnerabilities introduced)\n`;
    section += `- Authentication & Authorization: 82/100 (OAuth2 implemented, but gaps exist)\n`;
    section += `- Data Protection: 70/100 (Inter-service communication not encrypted)\n`;
    section += `- Input Validation: 73/100 (Multiple endpoints lack validation)\n`;
    section += `- Security Testing: 68/100 (Coverage gaps in new services)\n\n`;
    
    // Security improvements
    section += `### Security Improvements\n`;
    section += `- ✅ Fixed 5 SQL injection vulnerabilities\n`;
    section += `- ✅ Implemented OAuth2 + JWT for new services\n`;
    section += `- ✅ Added API Gateway with security policies\n`;
    section += `- ✅ Secrets moved to HashiCorp Vault\n\n`;
    
    section += `---\n\n`;
    return section;
  }

  private generatePerformanceAnalysis(comparison: ComparisonResult): string {
    const categoryScore = comparison.categoryScores?.performance || 65;
    const grade = this.getGrade(categoryScore);
    
    let section = `## 2. Performance Analysis\n\n`;
    section += `### Score: ${categoryScore}/100 (Grade: ${grade})\n\n`;
    
    // Detailed performance metrics as requested
    section += `**Score Breakdown:**\n`;
    section += `- Response Time: 62/100 (P95 degraded to 450ms)\n`;
    section += `- Throughput: 65/100 (Decreased to 3.5K RPS)\n`;
    section += `- Resource Efficiency: 68/100 (CPU 78%, Memory 82%)\n`;
    section += `- Scalability: 78/100 (Better horizontal scaling)\n`;
    section += `- Reliability: 60/100 (New failure modes introduced)\n\n`;
    
    section += `### Performance Improvements\n`;
    section += `- ✅ Services can now scale independently\n`;
    section += `- ✅ Implemented circuit breakers\n`;
    section += `- ✅ Added distributed caching layer\n\n`;
    
    section += `---\n\n`;
    return section;
  }

  private generateCodeQualityAnalysis(comparison: ComparisonResult): string {
    const categoryScore = comparison.categoryScores?.['code-quality'] || 76;
    const grade = this.getGrade(categoryScore);
    
    let section = `## 3. Code Quality Analysis\n\n`;
    section += `### Score: ${categoryScore}/100 (Grade: ${grade})\n\n`;
    
    section += `**Score Breakdown:**\n`;
    section += `- Maintainability: 79/100 (Increased complexity)\n`;
    section += `- Test Coverage: 71/100 (Decreased from 82%)\n`;
    section += `- Documentation: 78/100 (New services documented)\n`;
    section += `- Code Complexity: 73/100 (Distributed logic overhead)\n`;
    section += `- Standards Compliance: 82/100 (Some violations)\n\n`;
    
    section += `### Major Code Changes\n`;
    section += `- 📁 **${comparison.filesChanged || 89} files changed** (43 new, 31 modified, 15 deleted)\n`;
    section += `- 📏 **${comparison.linesChanged || 2847} lines changed** (+${comparison.linesAdded || 100} / -${comparison.linesRemoved || 50})\n`;
    section += `- 🧪 **Test coverage dropped** 82% → 71% (-11%)\n\n`;
    
    section += `---\n\n`;
    return section;
  }

  private generateArchitectureAnalysis(comparison: ComparisonResult): string {
    const categoryScore = comparison.categoryScores?.architecture || 85;
    const grade = this.getGrade(categoryScore);
    
    let section = `## 4. Architecture Analysis\n\n`;
    section += `### Score: ${categoryScore}/100 (Grade: ${grade})\n\n`;
    
    section += `**Score Breakdown:**\n`;
    section += `- Design Patterns: 94/100 (Excellent patterns)\n`;
    section += `- Modularity: 96/100 (Clear boundaries)\n`;
    
    // Add breaking changes impact if present
    const breakingChanges = comparison.breakingChanges || [];
    if (breakingChanges.length > 0) {
      const breakingScore = Math.max(45, 100 - (breakingChanges.length * 5));
      section += `- **Breaking Changes Impact: ${breakingScore}/100** ⚠️ (${breakingChanges.length} breaking changes)\n`;
    }
    
    section += `- Scalability Design: 93/100 (Horizontal scaling)\n`;
    section += `- Resilience: 87/100 (Circuit breakers need tuning)\n`;
    section += `- API Design: 91/100 (Missing versioning)\n\n`;
    
    // Generate dynamic architecture based on repository
    section += this.generateDynamicArchitectureDiagram(comparison);
    
    section += `---\n\n`;
    return section;
  }
  
  private generateDynamicArchitectureDiagram(comparison: ComparisonResult): string {
    const repoUrl = comparison.aiAnalysis?.repository || comparison.repository || '';
    const repoName = this.extractRepoName(repoUrl);
    const newIssues = comparison.comparison?.newIssues || [];
    const fixedIssues = comparison.comparison?.fixedIssues || [];
    
    // Determine architecture type based on repository and issues
    if (repoName.toLowerCase().includes('react') || repoName.toLowerCase().includes('vue') || repoName.toLowerCase().includes('angular')) {
      return this.generateFrontendArchitectureDiagram(repoName, newIssues, fixedIssues);
    } else if (repoName.toLowerCase().includes('api') || repoName.toLowerCase().includes('backend') || repoName.toLowerCase().includes('server')) {
      return this.generateBackendArchitectureDiagram(repoName, newIssues, fixedIssues);
    } else if (newIssues.some(i => i.category === 'architecture' && (i.message?.includes('microservice') || i.message?.includes('service')))) {
      return this.generateMicroservicesArchitectureDiagram(repoName, newIssues, fixedIssues);
    } else {
      return this.generateGenericArchitectureDiagram(repoName, newIssues, fixedIssues);
    }
  }
  
  private extractRepoName(repoUrl: string): string {
    const match = repoUrl.match(/\/([^/]+)$/);
    return match ? match[1] : 'repository';
  }
  
  private generateFrontendArchitectureDiagram(repoName: string, newIssues: Issue[], fixedIssues: Issue[]): string {
    let diagram = `### Architecture Transformation\n\n`;
    
    diagram += `**Before: Component Structure**\n`;
    diagram += '```\n';
    diagram += `┌─────────────────────────────────────────┐
│           ${repoName} App               │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │      Unorganized Components     │   │
│  │   - Mixed business logic        │   │
│  │   - Direct API calls            │   │
│  │   - Prop drilling               │   │
│  └─────────────────────────────────┘   │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │         Global State            │   │
│  │    (Scattered across app)       │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘\n`;
    diagram += '```\n\n';
    
    diagram += `**After: Modern Architecture**\n`;
    diagram += '```\n';
    diagram += `┌─────────────────────────────────────────────────────────┐
│                    ${repoName} App                        │
├─────────────────────────────────────────────────────────┤
│                  Presentation Layer                      │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐             │
│  │  Pages   │  │  Layouts │  │   UI     │             │
│  │  /views  │  │          │  │Components│             │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘             │
├───────┴──────────────┴──────────────┴───────────────────┤
│                  Business Logic Layer                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │    Hooks     │  │   Services   │  │    Store     │ │
│  │  (useAuth,   │  │  (API calls) │  │  (Redux/     │ │
│  │   useData)   │  │              │  │   Zustand)   │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
├─────────────────────────────────────────────────────────┤
│                    Data Layer                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │   REST API   │  │   GraphQL    │  │   WebSocket  │ │
│  │   Client     │  │    Client    │  │   Client     │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────┘\n`;
    diagram += '```\n\n';
    
    // Add specific improvements based on issues
    diagram += `### Key Architectural Improvements\n`;
    if (fixedIssues.length > 0) {
      diagram += `- ✅ Fixed ${fixedIssues.length} architectural issues\n`;
    }
    if (newIssues.some(i => i.category === 'performance')) {
      diagram += `- ⚠️ Performance optimizations needed (lazy loading, code splitting)\n`;
    }
    if (newIssues.some(i => i.category === 'architecture')) {
      diagram += `- ⚠️ ${newIssues.filter(i => i.category === 'architecture').length} new architectural concerns introduced\n`;
    }
    diagram += `- ✅ Clear separation of concerns\n`;
    diagram += `- ✅ Centralized state management\n`;
    diagram += `- ✅ Reusable component architecture\n\n`;
    
    return diagram;
  }
  
  private generateBackendArchitectureDiagram(repoName: string, newIssues: Issue[], fixedIssues: Issue[]): string {
    let diagram = `### Architecture Transformation\n\n`;
    
    diagram += `**Before: Traditional Layered Architecture**\n`;
    diagram += '```\n';
    diagram += `┌─────────────────────────────────────────┐
│            ${repoName}                  │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │         Controllers             │   │
│  │    (Thick controllers with      │   │
│  │     business logic mixed in)    │   │
│  └────────────┬────────────────────┘   │
│               │                         │
│  ┌────────────┴────────────────────┐   │
│  │         Database Layer          │   │
│  │    (Direct SQL queries,         │   │
│  │     No abstraction)             │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘\n`;
    diagram += '```\n\n';
    
    diagram += `**After: Clean Architecture**\n`;
    diagram += '```\n';
    diagram += `┌─────────────────────────────────────────────────────────┐
│                    API Gateway                           │
└──────────────────────┬──────────────────────────────────┘
                       │
┌──────────────────────┴──────────────────────────────────┐
│                 Presentation Layer                       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │  REST API    │  │   GraphQL    │  │  WebSocket   │ │
│  │  Controllers │  │   Resolvers  │  │   Handlers   │ │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘ │
└─────────┴──────────────────┴──────────────────┴─────────┘
                       │
┌──────────────────────┴──────────────────────────────────┐
│                Application Layer                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │   Use Cases  │  │   Services   │  │  Validators  │ │
│  │              │  │              │  │              │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
└─────────────────────────┬───────────────────────────────┘
                          │
┌─────────────────────────┴───────────────────────────────┐
│                   Domain Layer                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │   Entities   │  │ Value Objects│  │ Domain Events│ │
│  │              │  │              │  │              │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
└─────────────────────────┬───────────────────────────────┘
                          │
┌─────────────────────────┴───────────────────────────────┐
│              Infrastructure Layer                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │  Repository  │  │   Database   │  │  External    │ │
│  │  Impl        │  │   (PostgreSQL)│  │  Services   │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────┘\n`;
    diagram += '```\n\n';
    
    return diagram;
  }
  
  private generateMicroservicesArchitectureDiagram(repoName: string, newIssues: Issue[], fixedIssues: Issue[]): string {
    // This is the original microservices diagram, but now only used when appropriate
    let diagram = `### Architecture Transformation\n\n`;
    diagram += `**Before: Monolithic Architecture**\n`;
    diagram += '```\n';
    diagram += `┌─────────────────────────────────────────┐
│           Monolithic App                 │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐  │
│  │  Auth   │ │Business │ │  Data   │  │
│  │  Logic  │ │  Logic  │ │  Access │  │
│  └─────────┘ └─────────┘ └─────────┘  │
│                                         │
│           Single Database               │
└─────────────────────────────────────────┘\n`;
    diagram += '```\n\n';
    
    diagram += `**After: Microservices Architecture**\n`;
    diagram += '```\n';
    diagram += `┌─────────────────────────────────────────────────────────┐
│                    API Gateway                           │
└─────────────────────────┬───────────────────────────────┘
                          │
    ┌─────────────────────┼─────────────────────┐
    │                     │                     │
┌───┴────┐           ┌───┴────┐           ┌───┴────┐
│  Auth  │           │Business│           │  Data  │
│Service │           │Service │           │Service │
└───┬────┘           └───┬────┘           └───┬────┘
    │                     │                     │
┌───┴────┐           ┌───┴────┐           ┌───┴────┐
│Auth DB │           │Biz DB  │           │Data DB │
└────────┘           └────────┘           └────────┘

                   Event Bus (Kafka/RabbitMQ)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n`;
    diagram += '```\n\n';
    
    return diagram;
  }
  
  private generateGenericArchitectureDiagram(repoName: string, newIssues: Issue[], fixedIssues: Issue[]): string {
    let diagram = `### Architecture Analysis\n\n`;
    
    // Analyze the issues to determine what kind of architecture changes were made
    const archIssues = newIssues.filter(i => i.category === 'architecture');
    const perfIssues = newIssues.filter(i => i.category === 'performance');
    const securityIssues = newIssues.filter(i => i.category === 'security');
    
    diagram += `**Current Architecture State**\n`;
    diagram += '```\n';
    diagram += `┌─────────────────────────────────────────────────────────┐
│                    ${repoName}                          │
├─────────────────────────────────────────────────────────┤\n`;
    
    if (securityIssues.length > 0) {
      diagram += `│  Security Layer                                         │
│  ⚠️  ${securityIssues.length} security issues need attention              │
│  - Authentication gaps                                  │
│  - Authorization improvements needed                    │
├─────────────────────────────────────────────────────────┤\n`;
    }
    
    diagram += `│  Application Core                                       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │
│  │   Business  │  │   Domain    │  │   Service   │   │
│  │    Rules    │  │   Models    │  │    Layer    │   │
│  └─────────────┘  └─────────────┘  └─────────────┘   │\n`;
    
    if (perfIssues.length > 0) {
      diagram += `│  ⚠️  ${perfIssues.length} performance bottlenecks identified           │\n`;
    }
    
    diagram += `├─────────────────────────────────────────────────────────┤
│  Data Access Layer                                      │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │
│  │ Repositories│  │    Cache    │  │   Database  │   │
│  │             │  │             │  │   Connections│   │
│  └─────────────┘  └─────────────┘  └─────────────┘   │
└─────────────────────────────────────────────────────────┘\n`;
    diagram += '```\n\n';
    
    // Add recommendations based on issues
    diagram += `### Architectural Recommendations\n`;
    if (archIssues.length > 0) {
      diagram += `\n**Based on ${archIssues.length} architectural issues found:**\n`;
      archIssues.slice(0, 3).forEach(issue => {
        diagram += `- ${issue.title || issue.message}\n`;
      });
    }
    
    if (fixedIssues.filter(i => i.category === 'architecture').length > 0) {
      diagram += `\n**Architectural Improvements Made:**\n`;
      diagram += `- ✅ Fixed ${fixedIssues.filter(i => i.category === 'architecture').length} architectural issues\n`;
    }
    
    diagram += `\n`;
    
    return diagram;
  }

  private generateDependenciesAnalysis(comparison: ComparisonResult): string {
    const categoryScore = comparison.categoryScores?.dependencies || 70;
    const grade = this.getGrade(categoryScore);
    
    let section = `## 5. Dependencies Analysis\n\n`;
    section += `### Score: ${categoryScore}/100 (Grade: ${grade})\n\n`;
    
    section += `**Score Breakdown:**\n`;
    section += `- Security: 68/100 (8 vulnerabilities added)\n`;
    section += `- License Compliance: 90/100 (GPL dependency added)\n`;
    section += `- Version Currency: 72/100 (Using outdated versions)\n`;
    section += `- Bundle Efficiency: 65/100 (Images too large)\n`;
    section += `- Maintenance Health: 78/100 (Some abandoned packages)\n\n`;
    
    section += `### Container Size Issues\n`;
    section += `- User Service: 1.2GB (target: 400MB) - 3x larger\n`;
    section += `- Payment Service: 980MB (target: 350MB) - 2.8x larger\n`;
    section += `- Notification Service: 850MB (target: 300MB) - 2.8x larger\n\n`;
    
    section += `**Container Size Analysis:**\n`;
    section += '```dockerfile\n';
    section += `# Current problematic Dockerfile
FROM node:18
WORKDIR /app
COPY . .
RUN npm install
CMD ["node", "index.js"]
# Results in 1.2GB image!\n`;
    section += '```\n\n';
    
    section += `**Required Optimization:**\n`;
    section += '```dockerfile\n';
    section += `# Optimized multi-stage build
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

FROM node:18-alpine
RUN apk add --no-cache tini
WORKDIR /app
COPY --from=builder /app/node_modules ./node_modules
COPY . .
USER node
ENTRYPOINT ["/sbin/tini", "--"]
CMD ["node", "index.js"]
# Results in ~400MB image\n`;
    section += '```\n\n';
    
    section += `---\n\n`;
    return section;
  }

  private generatePRIssuesSection(comparison: ComparisonResult): string {
    const newIssues = comparison.comparison?.newIssues || [];
    if (newIssues.length === 0) return '';
    
    let section = `## 6. PR Issues (NEW - MUST BE FIXED)\n\n`;
    section += `*These issues were introduced in this PR and must be resolved before merge.*\n\n`;
    
    // Group by severity - ALL severities as requested
    const severities = ['critical', 'high', 'medium', 'low'];
    
    for (const severity of severities) {
      const severityIssues = newIssues.filter(i => i.severity === severity);
      if (severityIssues.length === 0) continue;
      
      const emoji = this.getSeverityEmoji(severity);
      const label = severity.charAt(0).toUpperCase() + severity.slice(1);
      
      section += `### ${emoji} ${label} Issues (${severityIssues.length})\n\n`;
      
      severityIssues.forEach((issue, index) => {
        section += this.formatIssueWithCodeSnippet(issue, index + 1, `PR-${severity.toUpperCase()}`);
      });
    }
    
    return section;
  }

  private generateRepositoryIssuesSection(comparison: ComparisonResult): string {
    const unfixedIssues = comparison.comparison?.unchangedIssues || [];
    if (unfixedIssues.length === 0) return '';
    
    let section = `## 7. Repository Issues (Pre-existing - NOT BLOCKING)\n\n`;
    section += `*These issues exist in the main branch and don't block this PR, but significantly impact skill scores.*\n\n`;
    
    // Group by severity
    const severities = ['critical', 'high', 'medium', 'low'];
    
    for (const severity of severities) {
      const severityIssues = unfixedIssues.filter(i => i.severity === severity);
      if (severityIssues.length === 0) continue;
      
      section += `### ${severity.charAt(0).toUpperCase() + severity.slice(1)} Repository Issues (${severityIssues.length})\n`;
      
      severityIssues.forEach((issue, index) => {
        section += `${index + 1}. **${issue.title || issue.message}** (${issue.age || 'unknown age'})\n`;
        section += `   - File: ${issue.location?.file || 'Unknown'}:${issue.location?.line || '?'}\n`;
        section += `   - Impact: ${issue.description || 'No description'}\n`;
        
        // Include code snippet for repo issues too
        if (issue.codeSnippet) {
          section += `   - Code: \`${issue.codeSnippet.substring(0, 50)}...\`\n`;
        }
        
        section += `   - **Skill Impact:** -${this.UNFIXED_PENALTIES[severity as keyof typeof this.UNFIXED_PENALTIES]} points for leaving ${severity} issue unfixed\n\n`;
      });
    }
    
    return section;
  }
<<<<<<< HEAD
=======
  
  private formatRepositoryIssue(issue: any, index: number, prefix: string): string {
    // Extract the actual issue if it's wrapped
    const actualIssue = issue.issue || issue;
    
    // Get issue details with fallbacks
    const title = actualIssue.title || actualIssue.message || actualIssue.Title || 'Unknown Issue';
    const file = actualIssue.location?.file || actualIssue.location || actualIssue.file || 'Unknown';
    const line = actualIssue.location?.line || actualIssue.line || '?';
    const impact = actualIssue.impact || actualIssue.description || actualIssue.remediation || `${actualIssue.category || 'Unknown'} issue in repository`;
    const cwe = actualIssue.CWE || actualIssue.cwe || '';
    const age = actualIssue.age || actualIssue.metadata?.firstDetected || 'Unknown';
    
    let formatted = `#### ${prefix}-${String(index).padStart(3, '0')}: ${title}\n`;
    formatted += `**File:** ${file}:${line}  \n`;
    if (cwe) formatted += `**CWE:** ${cwe}  \n`;
    formatted += `**Category:** ${actualIssue.category || 'Unknown'}  \n`;
    formatted += `**Severity:** ${actualIssue.severity || 'Unknown'}  \n`;
    formatted += `**Age:** ${age}  \n`;
    formatted += `**Impact:** ${impact}\n\n`;
    
    // Include full code snippet like PR issues
    formatted += `**Current Implementation:**\n`;
    formatted += '```' + this.getLanguageFromFile(actualIssue.location?.file) + '\n';
    // Check both direct property and metadata for code snippet
    const codeSnippet = actualIssue.codeSnippet || actualIssue.metadata?.codeSnippet || '// Code snippet not available\n';
    formatted += codeSnippet;
    formatted += '\n```\n\n';
    
    formatted += `**Required Fix:**\n`;
    formatted += '```' + this.getLanguageFromFile(actualIssue.location?.file) + '\n';
    
    // Generate actual code fix based on issue type
    const remediation = actualIssue.remediation || actualIssue.metadata?.remediation;
    let suggestedFix = actualIssue.suggestedFix || actualIssue.metadata?.suggestedFix;
    
    // Generate specific code fixes based on issue type
    if (actualIssue.id === 'PR-NEW-001' || actualIssue.title?.includes('Insecure Direct Object Reference')) {
      suggestedFix = `// Check user authorization before accessing resource
if (!req.user || req.user.id !== resource.ownerId) {
  return res.status(403).json({ error: 'Unauthorized access' });
}

// Proceed with resource access
const userData = await getUserData(req.params.id, req.user.id);`;
    } else if (actualIssue.id === 'PR-NEW-002' || actualIssue.title?.includes('Synchronous File I/O')) {
      suggestedFix = `// Replace synchronous file operations with async
// Before: const data = fs.readFileSync(filePath, 'utf8');
// After:
const data = await fs.promises.readFile(filePath, 'utf8');

// Or use streaming for large files:
const stream = fs.createReadStream(filePath);
stream.on('data', (chunk) => {
  // Process chunk
});`;
    } else if (actualIssue.title?.includes('SQL Injection')) {
      suggestedFix = `// Use parameterized queries instead of string concatenation
// Before: const query = "SELECT * FROM users WHERE id = " + userId;
// After:
const query = 'SELECT * FROM users WHERE id = ?';
const results = await db.query(query, [userId]);

// Or with named parameters:
const results = await db.query(
  'SELECT * FROM users WHERE id = :userId',
  { userId }
);`;
    } else if (actualIssue.title?.includes('XSS')) {
      suggestedFix = `// Sanitize user input before rendering
import DOMPurify from 'dompurify';

// Before: element.innerHTML = userContent;
// After:
const sanitized = DOMPurify.sanitize(userContent);
element.innerHTML = sanitized;

// Or use React's safe rendering:
return <div>{userContent}</div>; // React auto-escapes`;
    } else if (actualIssue.title?.includes('Memory Leak')) {
      suggestedFix = `// Add cleanup for event listeners and subscriptions
useEffect(() => {
  const handleResize = () => {
    // Handle resize
  };
  
  window.addEventListener('resize', handleResize);
  
  // Cleanup function
  return () => {
    window.removeEventListener('resize', handleResize);
  };
}, []);`;
    } else if (actualIssue.title?.includes('N+1 Query')) {
      suggestedFix = `// Batch fetch all data before iteration
// Before:
for (const member of members) {
  const details = await UserDetails.findOne({ userId: member.id });
}

// After:
const memberIds = members.map(m => m.id);
const allDetails = await UserDetails.find({ 
  userId: { $in: memberIds } 
});
const detailsMap = new Map(allDetails.map(d => [d.userId, d]));

for (const member of members) {
  const details = detailsMap.get(member.id);
  // Process details
}`;
    } else if (actualIssue.title?.includes('Bundle') || actualIssue.title?.includes('Oversized')) {
      suggestedFix = `// Optimize bundle size with code splitting
// webpack.config.js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\\\]node_modules[\\\\]/,
          name: 'vendors',
          priority: 10
        }
      }
    }
  }
};

// Use dynamic imports for large components
const HeavyComponent = lazy(() => import('./HeavyComponent'));`;
    } else if (actualIssue.title?.includes('Complexity')) {
      suggestedFix = `// Break down complex function into smaller units
// Before: 234 lines with complexity 24
// After:
function processAnalysis(data) {
  const validated = validateInput(data);
  const normalized = normalizeData(validated);
  const results = analyzeData(normalized);
  return formatResults(results);
}

function validateInput(data) {
  // Validation logic (10 lines)
}

function normalizeData(data) {
  // Normalization logic (15 lines)
}

function analyzeData(data) {
  // Analysis logic (20 lines)
}`;
    } else if (actualIssue.title?.includes('Vulnerable Dependency') || actualIssue.title?.includes('lodash')) {
      suggestedFix = `// Update vulnerable dependencies
// package.json
{
  "dependencies": {
    "lodash": "^4.17.21",  // Updated from 4.17.15
    // Consider using lodash-es for tree shaking:
    // "lodash-es": "^4.17.21"
  }
}

// Run update command:
npm update lodash
npm audit fix

// Or use yarn:
yarn upgrade lodash@^4.17.21`;
    } else if (actualIssue.title?.includes('Hardcoded') || actualIssue.title?.includes('API Key')) {
      suggestedFix = `// Move sensitive data to environment variables
// .env file (add to .gitignore)
DATABASE_URL=your_database_url
API_KEY=your_api_key
SECRET_TOKEN=your_secret_token

// config.js
require('dotenv').config();

module.exports = {
  database: process.env.DATABASE_URL,
  apiKey: process.env.API_KEY,
  secretToken: process.env.SECRET_TOKEN
};

// Usage
const config = require('./config');
const apiClient = new Client({ apiKey: config.apiKey });`;
    } else if (remediation?.immediate && remediation?.steps) {
      // Use remediation data if available with actual code
      suggestedFix = `// ${remediation.immediate}\n`;
      if (actualIssue.codeSnippet) {
        suggestedFix += `\n// Current vulnerable code:\n// ${actualIssue.codeSnippet.replace(/\n/g, '\n// ')}\n\n`;
      }
      suggestedFix += `// Fixed implementation:\n`;
      if (actualIssue.suggestedFix && !actualIssue.suggestedFix.startsWith('//')) {
        suggestedFix += actualIssue.suggestedFix;
      } else {
        // Generate a more specific fix based on the remediation steps
        suggestedFix += remediation.steps.map((step: string, i: number) => {
          if (step.includes('parameterized')) {
            return `// Use parameterized query\nconst result = await db.query('SELECT * FROM table WHERE id = ?', [id]);`;
          } else if (step.includes('sanitize') || step.includes('escape')) {
            return `// Sanitize input\nconst clean = DOMPurify.sanitize(userInput);`;
          } else if (step.includes('validate')) {
            return `// Validate input\nif (!validator.isEmail(email)) {\n  throw new Error('Invalid email');\n}`;
          } else {
            return `// ${step}`;
          }
        }).join('\n');
      }
    } else if (suggestedFix) {
      // Use existing suggested fix if available but enhance it
      if (!suggestedFix.includes('//') && !suggestedFix.includes('/*')) {
        suggestedFix = `// Suggested fix:\n${suggestedFix}`;
      }
    } else {
      // Generic fix template with more specific guidance
      suggestedFix = `// Fix for ${actualIssue.title || actualIssue.category || 'this issue'}\n// Step 1: Review the vulnerable code at line ${actualIssue.location?.line || 'N/A'}\n// Step 2: Apply the following fix:\n\n// Example implementation:\nif (${actualIssue.category === 'security' ? 'validate_input(data)' : 'check_condition()'}) {\n  // Safe processing\n  const result = process_safely(data);\n  return result;\n} else {\n  throw new Error('Validation failed');\n}`;
    }
    
    formatted += suggestedFix;
    formatted += '\n```\n\n';
    
    return formatted;
  }
>>>>>>> 939a392 (feat: Implement DiffAnalyzer service for accurate PR issue detection)

  private generateEducationalInsights(comparison: ComparisonResult): string {
    let section = `## 8. Educational Insights & Recommendations\n\n`;
    
    section += `### Learning Path Based on This PR\n\n`;
    
    section += `#### Immediate Learning Needs (Critical - This Week)\n`;
    section += `1. **Microservices Security** (6 hours) 🚨\n`;
    section += `   - Service mesh security (mTLS)\n`;
    section += `   - API Gateway security patterns\n`;
    section += `   - Zero-trust networking\n`;
    section += `   - **Why:** You exposed internal APIs without auth\n\n`;
    
    section += `2. **Distributed System Performance** (8 hours) 🚨\n`;
    section += `   - Avoiding distributed N+1 queries\n`;
    section += `   - Async communication patterns\n`;
    section += `   - Distributed tracing\n`;
    section += `   - **Why:** Critical performance degradation\n\n`;
    
    section += `### Anti-Patterns to Avoid\n\n`;
    section += `**❌ What You Did Wrong:**\n`;
    section += '```typescript\n';
    section += `// Never expose internal APIs without auth
router.get('/internal/users/:id/full', async (req, res) => {
  const user = await userRepository.getFullUserData(req.params.id);
  res.json(user); // CRITICAL: No authentication!
});

// Never create N+1 queries in loops
for (const member of members) {
  const details = await UserDetails.findOne({ userId: member.id });
  // This creates thousands of queries!
}\n`;
    section += '```\n\n';
    
    section += `**✅ What You Did Right:**\n`;
    section += '```typescript\n';
    section += `// Good: Event-driven architecture
eventBus.emit('payment.processed', { orderId, paymentId });

// Good: Circuit breaker pattern
const paymentService = CircuitBreaker(externalPaymentAPI, {
  timeout: 3000,
  errorThreshold: 50
});\n`;
    section += '```\n\n';
    
    section += `---\n\n`;
    return section;
  }

  private generateSkillsTracking(comparison: ComparisonResult): string {
    // Extract author info dynamically
    const repoUrl = comparison.aiAnalysis?.repository || comparison.repository;
    const username = this.extractUsernameFromRepo(repoUrl);
    const author = comparison.aiAnalysis?.author || { 
      name: this.formatUsername(username), 
      username: username 
    };
    
    const previousScore = 75;
    const currentScore = this.calculateDeveloperScore(comparison, previousScore);
    
    let section = `## 9. Individual & Team Skills Tracking\n\n`;
    
    section += `### Individual Developer Progress\n\n`;
    section += `**Developer:** ${author.name} (@${author.username})  \n`;
    section += `**Status:** Senior Developer (18 months tenure)\n\n`;
    section += `**Overall Skill Level: ${currentScore}/100 (${this.getGrade(currentScore)})**\n\n`;
    
    section += `*Detailed Calculation Breakdown:*\n`;
    section += `- Previous Score: ${previousScore}/100\n`;
    section += `- Base adjustment for PR (68/100): +3 → Starting at 78\n\n`;
    
    section += `**Positive Adjustments: +25**\n`;
    section += `- Fixed 5 critical issues: +25 (5 × 5)\n\n`;
    
    section += `**Negative Adjustments: -52**\n`;
    section += `- New critical issues: -10 (2 × -5)\n`;
    section += `- New high issues: -9 (3 × -3)\n`;
    section += `- New medium issues: -4 (4 × -1)\n`;
    section += `- New low issues: -1.5 (3 × -0.5)\n`;
    section += `- Vulnerable dependencies: -6 (8 deps × -0.75)\n`;
    section += `- Coverage decrease: -3 (11% drop)\n`;
    section += `- Unfixed critical issues: -15 (3 × -5)\n`;
    section += `- Unfixed high issues: -15 (5 × -3)\n`;
    section += `- Unfixed medium issues: -4 (4 × -1)\n`;
    section += `- Unfixed low issues: -1.5 (3 × -0.5)\n\n`;
    
    section += `**Final Score: ${currentScore}/100** (${currentScore - previousScore} from previous)\n\n`;
    
    // Skills table
    section += `| Skill | Previous | Current | Change | Detailed Calculation |\n`;
    section += `|-------|----------|---------|---------|---------------------|\n`;
    section += `| Security | 82/100 | 65/100 | -17 | Fixed critical: +25, New: -19, Unfixed: -23 |\n`;
    section += `| Performance | 78/100 | 59/100 | -19 | New critical: -10, New high: -9, Unfixed: -9, Improvements: +9 |\n`;
    section += `| Architecture | 85/100 | 88/100 | +3 | Excellent patterns: +7, New issues: -2, Unfixed: -2 |\n`;
    section += `| Code Quality | 88/100 | 73/100 | -15 | Coverage drop: -6, Complexity: -3, New issues: -2, Unfixed: -4 |\n`;
    section += `| Dependencies | 80/100 | 70/100 | -10 | 8 vulnerable added: -6, Unfixed vulns: -4 |\n`;
    section += `| Testing | 76/100 | 68/100 | -8 | Coverage 82% → 71% (-11%) |\n\n`;
    
    section += `### Team Skills Analysis\n\n`;
    section += `**Team Performance Overview**\n\n`;
    section += `**Team Average: 59/100 (F)**\n\n`;
    
    section += `| Developer | Overall | Security | Perf | Quality | Deps | Status | Trend |\n`;
    section += `|-----------|---------|----------|------|---------|------|--------|-------|\n`;
    section += `| Sarah Chen | 61/100 | 65/100 | 59/100 | 73/100 | 70/100 | Senior | ↓↓ |\n`;
    section += `| John Smith | 62/100 | 65/100 | 58/100 | 68/100 | 70/100 | Mid | → |\n`;
    section += `| Alex Kumar | 54/100 | 54/100 | 54/100 | 54/100 | 54/100 | Junior | 🆕 |\n`;
    
    section += `\n---\n\n`;
    return section;
  }

  private generateBusinessImpact(comparison: ComparisonResult): string {
    let section = `## 10. Business Impact Analysis\n\n`;
    
    section += `### Negative Impacts (Severe)\n`;
    section += `- ❌ **Security Risk**: CRITICAL - Data breach imminent\n`;
    section += `- ❌ **Performance**: 45% latency increase = SLA violations\n`;
    section += `- ❌ **Reliability**: New failure modes = increased downtime\n`;
    section += `- ❌ **Compliance**: PCI-DSS violations = potential fines\n`;
    section += `- ❌ **Technical Debt**: +35% = slower future development\n`;
    section += `- ❌ **Operational Cost**: 3x infrastructure cost\n\n`;
    
    section += `### Positive Impacts (Future potential)\n`;
    section += `- ✅ **Scalability**: 10x growth capacity (once issues fixed)\n`;
    section += `- ✅ **Team Autonomy**: Independent deployments\n`;
    section += `- ✅ **Architecture**: Modern microservices foundation\n\n`;
    
    section += `### Risk Assessment\n`;
    section += `- **Immediate Risk**: CRITICAL (from new issues)\n`;
    section += `- **Potential Breach Cost**: $2.5M - $5M\n`;
    section += `- **Compliance Fines**: Up to $500K\n`;
    section += `- **Customer Impact**: 45% slower = churn risk\n`;
    section += `- **Time to Stabilize**: 4-6 sprints minimum\n\n`;
    
    section += `---\n\n`;
    return section;
  }

  private generateActionItems(comparison: ComparisonResult): string {
    let section = `## 11. Action Items & Recommendations\n\n`;
    
    // Add breaking changes section if present
    const breakingChanges = comparison.breakingChanges || [];
    if (breakingChanges.length > 0) {
      section += `### 🚨 Must Fix Before Merge (BREAKING CHANGES)\n\n`;
      section += `#### Critical Breaking Changes (Immediate - BLOCKING)\n`;
      
      breakingChanges.slice(0, 5).forEach((change, index) => {
        section += `${index + 1}. **[${change.component}]**: ${change.description}\n`;
        if (change.migrationPath) {
          section += `   - Migration: ${change.migrationPath.split('\n')[0]}...\n`;
        }
      });
      
      if (breakingChanges.length > 5) {
        section += `\n... and ${breakingChanges.length - 5} more breaking changes\n`;
      }
      
      section += `\n**Required Actions:**\n`;
      section += `- Add comprehensive migration guide\n`;
      section += `- Document all breaking changes in CHANGELOG\n`;
      section += `- Version the API appropriately\n`;
      section += `- Add deprecation warnings for removed features\n\n`;
    }
    
    section += `### 🚨 Must Fix Before Merge (PR ISSUES ONLY)\n\n`;
    
    section += `#### Critical Issues (Immediate - BLOCKING)\n`;
    section += `1. **[PR-CRIT-SEC-001]** Secure internal APIs - Add service-to-service auth\n`;
    section += `2. **[PR-CRIT-PERF-001]** Fix N+1 query amplification (10,000+ queries)\n\n`;
    
    section += `#### High Issues (This Week - BLOCKING)\n`;
    section += `1. **[PR-HIGH-SEC-001]** Remove API keys from logs\n`;
    section += `2. **[PR-HIGH-SEC-002]** Configure CORS to specific origins\n`;
    section += `3. **[PR-HIGH-PERF-001]** Add missing database indexes\n\n`;
    
    section += `#### Dependency Updates (BLOCKING)\n`;
    section += '```bash\n';
    section += `npm update express@^4.19.2 jsonwebtoken@^9.0.0 axios@^1.6.0
npm update lodash@^4.17.21 moment@^2.29.4 minimist@^1.2.8
npm update node-fetch@^2.6.7 y18n@^4.0.3
npm audit fix --force\n`;
    section += '```\n\n';
    
    section += `### 📋 Technical Debt (Repository Issues - Not Blocking)\n\n`;
    
    section += `#### Critical Repository Issues (Next Sprint)\n`;
    section += `1. Fix hardcoded database credentials (6 months old)\n`;
    section += `2. Add rate limiting to auth endpoints (4 months old)\n`;
    section += `3. Fix memory leak in cache service (3 months old)\n\n`;
    
    section += `---\n\n`;
    return section;
  }

  private generateConclusion(comparison: ComparisonResult, decision: any): string {
    const newCritical = (comparison.comparison?.newIssues || []).filter(i => i.severity === 'critical').length;
    const newHigh = (comparison.comparison?.newIssues || []).filter(i => i.severity === 'high').length;
    const unfixedTotal = (comparison.comparison?.unchangedIssues || []).length;
    
    let section = `## 12. PR Comment Conclusion\n\n`;
    section += `### 📋 Summary for PR Review\n\n`;
    section += `**Decision: ${decision.decision}**\n\n`;
    
    if (newCritical > 0 || newHigh > 0) {
      section += `This PR cannot proceed with ${newCritical} new critical and ${newHigh} new high severity issues. `;
    }
    section += `Pre-existing repository issues don't block this PR but significantly impact skill scores.\n\n`;
    
    section += `**NEW Blocking Issues (Must Fix):**\n`;
    section += `- 🚨 ${newCritical} Critical\n`;
    section += `- 🚨 ${newHigh} High\n\n`;
    
    section += `**Pre-existing Repository Issues (Not blocking, but penalize scores):**\n`;
    section += `- ⚠️ ${unfixedTotal} total issues\n`;
    section += `- 💰 Skill penalty: -${this.calculateUnfixedPenalty(comparison)} points total\n\n`;
    
    section += `---\n\n`;
    return section;
  }

  private generateScoreSummary(comparison: ComparisonResult): string {
    let section = `## Score Impact Summary\n\n`;
    section += `| Category | Before | After | Change | Trend | Grade |\n`;
    section += `|----------|--------|-------|--------|-------|-------|\n`;
    
    const categories = ['Security', 'Performance', 'Code Quality', 'Architecture', 'Dependencies'];
    categories.forEach(cat => {
      const key = cat.toLowerCase().replace(' ', '-');
      const score = comparison.categoryScores?.[key] || 75;
      const prevScore = score + (Math.random() * 10 - 5); // Simulated previous score
      const change = score - prevScore;
      const trend = change > 0 ? '↑' : change < 0 ? '↓' : '→';
      section += `| ${cat} | ${Math.round(prevScore)}/100 | ${score}/100 | ${change > 0 ? '+' : ''}${Math.round(change)} | ${trend} | ${this.getGrade(score)} |\n`;
    });
    
    const overallScore = this.calculateOverallScore(comparison);
    section += `| **Overall** | **74/100** | **${overallScore}/100** | **${overallScore - 74}** | **↓** | **${this.getGrade(overallScore)}** |\n`;
    
    return section;
  }

  private formatIssueWithCodeSnippet(issue: Issue, index: number, prefix: string): string {
    let formatted = `#### ${prefix}-${String(index).padStart(3, '0')}: ${issue.title || issue.message || 'Unknown Issue'}\n`;
    formatted += `**File:** ${issue.location?.file || 'Unknown'}:${issue.location?.line || '?'}  \n`;
    formatted += `**Impact:** ${issue.description || 'No description provided'}\n\n`;
    
    // Always include code snippet for all severities
    formatted += `**Problematic Code:**\n`;
    formatted += '```' + this.getLanguageFromFile(issue.location?.file) + '\n';
    formatted += issue.codeSnippet || '// Code snippet not available\n// TODO: Check implementation';
    formatted += '\n```\n\n';
    
    formatted += `**Required Fix:**\n`;
    formatted += '```' + this.getLanguageFromFile(issue.location?.file) + '\n';
<<<<<<< HEAD
    formatted += issue.suggestedFix || '// TODO: Implement fix for this issue\n// Follow secure coding practices';
=======
    
    // Generate specific code fix for repository issues
    let suggestedFix = issue.suggestedFix || issue.metadata?.suggestedFix;
    
    // Apply same fix generation logic as PR issues
    if (issue.title?.includes('SQL Injection')) {
      suggestedFix = `// Use parameterized queries\nconst query = 'SELECT * FROM users WHERE id = ?';\nconst results = await db.query(query, [userId]);`;
    } else if (issue.title?.includes('XSS')) {
      suggestedFix = `// Sanitize HTML content\nimport DOMPurify from 'dompurify';\nconst clean = DOMPurify.sanitize(userContent);\nelement.innerHTML = clean;`;
    } else if (!suggestedFix) {
      suggestedFix = `// TODO: Fix ${issue.title || 'this issue'}\n// Apply security best practices`;
    }
    
    formatted += suggestedFix;
>>>>>>> 939a392 (feat: Implement DiffAnalyzer service for accurate PR issue detection)
    formatted += '\n```\n\n';
    
    formatted += `---\n\n`;
    return formatted;
  }

  private getLanguageFromFile(filePath?: string): string {
    if (!filePath) return 'typescript';
    const ext = filePath.split('.').pop()?.toLowerCase();
    const langMap: Record<string, string> = {
      js: 'javascript',
      jsx: 'javascript',
      ts: 'typescript',
      tsx: 'typescript',
      py: 'python',
      java: 'java',
      go: 'go',
      rs: 'rust',
      cpp: 'cpp',
      c: 'c',
      cs: 'csharp',
      rb: 'ruby',
      php: 'php',
      swift: 'swift',
      kt: 'kotlin'
    };
    return langMap[ext || ''] || 'text';
  }

  private generateIssueDistribution(comparison: ComparisonResult): string {
    const newIssues = comparison.comparison?.newIssues || [];
    const unfixedIssues = comparison.comparison?.unchangedIssues || [];
    
    let dist = '### Issue Distribution\n```\n';
    
    // New issues
    dist += 'NEW PR ISSUES (BLOCKING):\n';
    ['critical', 'high', 'medium', 'low'].forEach(severity => {
      const count = newIssues.filter(i => i.severity === severity).length;
      dist += `${severity.charAt(0).toUpperCase() + severity.slice(1)}: ${this.generateBar(count, 10)} ${count}`;
      if (severity === 'critical' || severity === 'high') {
        if (count > 0) dist += ' - MUST FIX';
      } else {
        dist += ' (acceptable)';
      }
      dist += '\n';
    });
    
    dist += '\n';
    
    // Existing unfixed
    dist += 'EXISTING REPOSITORY ISSUES (NOT BLOCKING):\n';
    ['critical', 'high', 'medium', 'low'].forEach(severity => {
      const count = unfixedIssues.filter(i => i.severity === severity).length;
      dist += `${severity.charAt(0).toUpperCase() + severity.slice(1)}: ${this.generateBar(count, 10)} ${count} unfixed\n`;
    });
    
    dist += '```\n';
    return dist;
  }

  private generateBar(count: number, max: number): string {
    const filled = Math.min(count, max);
    const empty = max - filled;
    return '█'.repeat(filled) + '░'.repeat(empty);
  }

  private calculateOverallScore(comparison: ComparisonResult): number {
    // Use scoring values to calculate
    const baseScore = 100;
    let score = baseScore;
    
    const newIssues = comparison.comparison?.newIssues || [];
    const unfixedIssues = comparison.comparison?.unchangedIssues || [];
    
    // Deduct for new issues
    newIssues.forEach(issue => {
      score -= this.SCORING_VALUES[issue.severity as keyof typeof this.SCORING_VALUES] || 0;
    });
    
    // Deduct for unfixed issues (same penalty as requested)
    unfixedIssues.forEach(issue => {
      score -= this.UNFIXED_PENALTIES[issue.severity as keyof typeof this.UNFIXED_PENALTIES] || 0;
    });
    
    // Deduct for breaking changes
    const breakingChanges = comparison.breakingChanges || [];
    const breakingChangePenalty = breakingChanges.reduce((penalty, change) => {
      switch (change.severity) {
        case 'critical': return penalty + 10;
        case 'high': return penalty + 5;
        case 'medium': return penalty + 3;
        case 'low': return penalty + 1;
        default: return penalty;
      }
    }, 0);
    score -= breakingChangePenalty;
    
    return Math.max(0, Math.round(score));
  }

  private calculateDeveloperScore(comparison: ComparisonResult, previousScore: number): number {
    let score = previousScore;
    
    // Apply adjustments based on PR quality
    const prQuality = this.calculateOverallScore(comparison);
    const adjustment = (prQuality - 70) / 10; // Adjust by ±1 per 10 points from 70
    score += adjustment;
    
    // Fixed issues bonus
    const fixedIssues = comparison.comparison?.fixedIssues || [];
    fixedIssues.forEach(issue => {
      score += this.SCORING_VALUES[issue.severity as keyof typeof this.SCORING_VALUES] || 0;
    });
    
    // New issues penalty
    const newIssues = comparison.comparison?.newIssues || [];
    newIssues.forEach(issue => {
      score -= this.SCORING_VALUES[issue.severity as keyof typeof this.SCORING_VALUES] || 0;
    });
    
    // Unfixed issues penalty
    const unfixedIssues = comparison.comparison?.unchangedIssues || [];
    unfixedIssues.forEach(issue => {
      score -= this.UNFIXED_PENALTIES[issue.severity as keyof typeof this.UNFIXED_PENALTIES] || 0;
    });
    
    return Math.max(0, Math.min(100, Math.round(score)));
  }

  private calculateUnfixedPenalty(comparison: ComparisonResult): number {
    const unfixedIssues = comparison.comparison?.unchangedIssues || [];
    let penalty = 0;
    
    unfixedIssues.forEach(issue => {
      penalty += this.UNFIXED_PENALTIES[issue.severity as keyof typeof this.UNFIXED_PENALTIES] || 0;
    });
    
    return penalty;
  }

  private makeDecision(comparison: ComparisonResult): any {
<<<<<<< HEAD
    const newIssues = comparison.comparison?.newIssues || [];
    const criticalNew = newIssues.filter(i => i.severity === 'critical').length;
    const highNew = newIssues.filter(i => i.severity === 'high').length;
=======
    const newIssues = comparison.comparison?.newIssues || comparison.newIssues || [];
    const criticalNew = newIssues.filter((i: any) => i.severity === 'critical').length;
    const highNew = newIssues.filter((i: any) => i.severity === 'high').length;
    const breakingChanges = comparison.breakingChanges || [];
    const criticalBreaking = breakingChanges.filter(c => c.severity === 'critical').length;
    
    // Check for critical breaking changes first
    if (criticalBreaking > 0) {
      return {
        decision: '❌ DECLINED - CRITICAL BREAKING CHANGES',
        confidence: 95,
        reason: `This PR introduces ${breakingChanges.length} breaking changes (${criticalBreaking} critical) that must be addressed.`
      };
    }
    
    // Check for breaking changes without migration guide
    if (breakingChanges.length > 0 && !breakingChanges.every(c => c.migrationPath)) {
      return {
        decision: '❌ DECLINED - BREAKING CHANGES REQUIRE MIGRATION PLAN',
        confidence: 92,
        reason: `This PR introduces ${breakingChanges.length} breaking changes that require migration guides.`
      };
    }
>>>>>>> 0fb7923 (feat: Integrate DiffAnalyzer breaking changes into V7 report template)
    
    if (criticalNew > 0 || highNew > 0) {
      return {
        decision: '❌ DECLINED - CRITICAL/HIGH ISSUES MUST BE FIXED',
        confidence: 92,
        reason: `${criticalNew} critical and ${highNew} high severity issues must be resolved`
      };
    }
    
    return {
      decision: '✅ APPROVED - Ready to merge',
      confidence: 88,
      reason: 'No blocking issues found'
    };
  }

  private getGrade(score: number): string {
    if (score >= 90) return 'A';
    if (score >= 80) return 'B';
    if (score >= 70) return 'C';
    if (score >= 60) return 'D';
    return 'F';
  }

  private getRiskLevel(comparison: ComparisonResult): string {
    const newIssues = comparison.comparison?.newIssues || [];
    const critical = newIssues.filter(i => i.severity === 'critical').length;
    const high = newIssues.filter(i => i.severity === 'high').length;
    
    if (critical > 0) return 'CRITICAL';
    if (high > 0) return 'HIGH';
    if (newIssues.length > 10) return 'MEDIUM';
    return 'LOW';
  }

  private estimateReviewTime(comparison: ComparisonResult): number {
    const baseTime = 30;
    const filesTime = (comparison.filesChanged || 0) * 2;
    const issuesTime = ((comparison.comparison?.newIssues || []).length + 
                       (comparison.comparison?.unchangedIssues || []).length) * 5;
    return baseTime + filesTime + issuesTime;
  }

  private getSeverityEmoji(severity: string): string {
    const emojis = {
      critical: '🚨',
      high: '⚠️',
      medium: '🟡',
      low: '🟢'
    };
    return emojis[severity as keyof typeof emojis] || '⚪';
  }
<<<<<<< HEAD
=======
  
  private generateFootnotes(): string {
    let footnotes = '\n---\n\n';
    footnotes += '## 📄 Report Footnotes\n\n';
    
    footnotes += '### Understanding the Scoring System\n\n';
    
    footnotes += '*** Score Calculation Method:**\n';
    footnotes += 'The developer skill score tracks improvement over time based on code quality. Each developer starts with their previous score, ';
    footnotes += 'which is then adjusted based on:\n\n';
    
    footnotes += '1. **PR Quality Adjustment**: The overall quality of this PR affects the starting point\n';
    footnotes += '   - PRs scoring 70/100 or higher provide small positive adjustments\n';
    footnotes += '   - PRs scoring below 70/100 provide small negative adjustments\n';
    footnotes += '   - This encourages maintaining high code quality standards\n\n';
    
    footnotes += '2. **Points for Fixing Issues**: Developers earn points by fixing existing problems\n';
    footnotes += '   - Critical issues: +5 points each\n';
    footnotes += '   - High issues: +3 points each\n';
    footnotes += '   - Medium issues: +1 point each\n';
    footnotes += '   - Low issues: +0.5 points each\n\n';
    
    footnotes += '3. **Penalties for New Issues**: Points are deducted for introducing new problems\n';
    footnotes += '   - Critical issues: -5 points each\n';
    footnotes += '   - High issues: -3 points each\n';
    footnotes += '   - Medium issues: -1 point each\n';
    footnotes += '   - Low issues: -0.5 points each\n\n';
    
    footnotes += '4. **Penalties for Ignoring Existing Issues**: Pre-existing issues that remain unfixed also result in penalties\n';
    footnotes += '   - Same point values as new issues\n';
    footnotes += '   - This incentivizes cleaning up technical debt\n';
    footnotes += '   - Note: These issues don\'t block PR approval but do impact scores\n\n';
    
    footnotes += '**** Quality Adjustment Calculation:**\n';
    footnotes += 'For every 10 points the PR quality differs from 70/100, the developer\'s starting score adjusts by ±1 point. ';
    footnotes += 'For example, a PR scoring 90/100 provides a +2 adjustment, while a PR scoring 50/100 provides a -2 adjustment.\n\n';
    
    footnotes += '***** Pre-existing Issues:**\n';
    footnotes += 'These are problems that existed in the codebase before this PR. While they don\'t block merging, ';
    footnotes += 'they impact developer scores to encourage gradual improvement of the codebase. The age of each issue ';
    footnotes += 'is tracked to identify long-standing technical debt.\n\n';
    
    footnotes += '### Severity Definitions\n\n';
    footnotes += '- **🚨 Critical**: Security vulnerabilities, data loss risks, or issues that can crash the application\n';
    footnotes += '- **⚠️ High**: Major bugs, performance problems, or security risks that significantly impact users\n';
    footnotes += '- **🔶 Medium**: Code quality issues, minor bugs, or problems that affect maintainability\n';
    footnotes += '- **🔴 Low**: Style violations, minor improvements, or nice-to-have enhancements\n\n';
    
    footnotes += '### Grade Scale\n\n';
    footnotes += '- **A (90-100)**: Exceptional - Industry best practices\n';
    footnotes += '- **B (80-89)**: Good - Minor improvements needed\n';
    footnotes += '- **C (70-79)**: Acceptable - Several areas for improvement\n';
    footnotes += '- **D (60-69)**: Poor - Significant issues present\n';
    footnotes += '- **F (0-59)**: Failing - Major problems requiring immediate attention\n\n';
    
    footnotes += '### Breaking Change Detection Methodology\n\n';
    footnotes += 'This report uses advanced diff analysis to detect breaking changes by:\n';
    footnotes += '1. **Comparing function signatures** between main and PR branches\n';
    footnotes += '2. **Analyzing export changes** to detect removed APIs\n';
    footnotes += '3. **Tracking configuration schema** modifications\n';
    footnotes += '4. **Calculating impact radius** through dependency analysis\n';
    footnotes += '5. **Providing confidence scores** based on verification\n\n';
    
    footnotes += '**Breaking Change Severity Levels:**\n';
    footnotes += '- **🚨 Critical**: Will break compilation or runtime\n';
    footnotes += '- **⚠️ High**: Requires code changes to maintain compatibility\n';
    footnotes += '- **🔶 Medium**: May affect behavior but won\'t break\n';
    footnotes += '- **🔴 Low**: Deprecation or minor changes\n\n';
    
    return footnotes;
  }
>>>>>>> 0fb7923 (feat: Integrate DiffAnalyzer breaking changes into V7 report template)

  /**
   * Generate markdown report - wrapper for generateReport method
   */
  generateMarkdownReport(comparison: ComparisonResult): string {
    return this.generateReport(comparison);
  }

  /**
   * Generate PR comment from comparison result
   */
  generatePRComment(comparison: ComparisonResult): string {
    const decision = this.makeDecision(comparison);
    const newIssues = comparison.comparison?.newIssues || [];
    const criticalNew = newIssues.filter(i => i.severity === 'critical').length;
    const highNew = newIssues.filter(i => i.severity === 'high').length;
    const mediumNew = newIssues.filter(i => i.severity === 'medium').length;
    const lowNew = newIssues.filter(i => i.severity === 'low').length;
    
    let comment = `## 🔍 Code Analysis Results\n\n`;
    comment += `**Decision:** ${decision.decision}\n`;
    comment += `**Confidence:** ${decision.confidence}%\n\n`;
    
    if (criticalNew > 0 || highNew > 0) {
      comment += `### 🚨 Blocking Issues Found\n`;
      comment += `This PR introduces **${criticalNew} critical** and **${highNew} high** severity issues that must be fixed before merging.\n\n`;
    }
    
    comment += `### 📊 Issue Summary\n`;
    comment += `| Severity | New Issues | Action Required |\n`;
    comment += `|----------|------------|----------------|\n`;
    comment += `| 🚨 Critical | ${criticalNew} | ${criticalNew > 0 ? 'MUST FIX' : 'None'} |\n`;
    comment += `| ⚠️ High | ${highNew} | ${highNew > 0 ? 'MUST FIX' : 'None'} |\n`;
    comment += `| 🟡 Medium | ${mediumNew} | ${mediumNew > 0 ? 'Review recommended' : 'None'} |\n`;
    comment += `| 🟢 Low | ${lowNew} | ${lowNew > 0 ? 'Consider fixing' : 'None'} |\n\n`;
    
    if (criticalNew > 0 || highNew > 0) {
      comment += `### 🛑 Next Steps\n`;
      comment += `1. Fix all critical and high severity issues\n`;
      comment += `2. Re-run analysis after fixes\n`;
      comment += `3. Request re-review once issues are resolved\n\n`;
    } else {
      comment += `### ✅ Ready to Merge\n`;
      comment += `No blocking issues found. This PR is ready for review and merge.\n\n`;
    }
    
    const overallScore = this.calculateOverallScore(comparison);
    comment += `**Overall Score:** ${overallScore}/100 (${this.getGrade(overallScore)})\n\n`;
    comment += `---\n`;
    comment += `*Generated by CodeQual Analysis Engine*`;
    
    return comment;
  }
}