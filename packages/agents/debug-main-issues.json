[
  {
    "id": "existing-critical-1",
    "severity": "critical",
    "category": "security",
    "title": "Hardcoded Database Credentials",
    "description": "Database credentials are hardcoded in source code",
    "location": {
      "file": "src/config/database.ts",
      "line": 15,
      "column": 8
    },
    "codeSnippet": "// CRITICAL: Hardcoded credentials in source!\nconst dbConfig = {\n  host: 'prod-db.example.com',\n  user: 'admin',\n  password: 'hardcoded_password',  // NEVER DO THIS!\n  database: 'production'\n};",
    "recommendation": "Move credentials to environment variables",
    "suggestion": "Replace hardcoded values with process.env.DB_PASSWORD and process.env.DB_USER",
    "remediation": "// Instead of:\nconst dbConfig = {\n  password: 'hardcoded_password',\n  user: 'admin'\n};\n\n// Use:\nconst dbConfig = {\n  password: process.env.DB_PASSWORD,\n  user: process.env.DB_USER\n};",
    "rule": "hardcoded-secrets",
    "message": "Database credentials are hardcoded in source code"
  },
  {
    "id": "existing-high-1",
    "severity": "high",
    "category": "security",
    "title": "SQL Injection Vulnerability",
    "description": "User input is not properly sanitized in query",
    "location": {
      "file": "src/api/users.ts",
      "line": 45,
      "column": 12
    },
    "codeSnippet": "// VULNERABLE: Direct string concatenation\nconst userId = req.params.id;\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\nconst result = await db.query(query);  // SQL injection risk!",
    "recommendation": "Use parameterized queries",
    "suggestion": "Replace string concatenation with parameterized queries using prepared statements",
    "remediation": "// Instead of:\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// Use:\nconst query = \"SELECT * FROM users WHERE id = ?\";\ndb.query(query, [userId]);",
    "rule": "sql-injection",
    "message": "User input is not properly sanitized in query"
  },
  {
    "id": "existing-medium-1",
    "severity": "medium",
    "category": "performance",
    "title": "Memory Leak in Cache Service",
    "description": "Cache grows unbounded leading to memory issues",
    "location": {
      "file": "src/services/cache.ts",
      "line": 89,
      "column": 4
    },
    "codeSnippet": "// Memory leak: No cache eviction\nclass CacheService {\n  private cache = new Map();\n  \n  set(key: string, value: any) {\n    // Cache grows forever!\n    this.cache.set(key, value);\n  }\n}",
    "recommendation": "Implement cache eviction policy",
    "suggestion": "Add LRU cache with max size limit",
    "remediation": "// Implement LRU cache:\nimport LRU from 'lru-cache';\n\nclass CacheService {\n  private cache = new LRU({\n    max: 500,  // Maximum items\n    ttl: 1000 * 60 * 60  // 1 hour TTL\n  });\n  \n  set(key: string, value: any) {\n    this.cache.set(key, value);\n  }\n}",
    "rule": "memory-leak",
    "message": "Cache grows unbounded leading to memory issues"
  },
  {
    "id": "existing-low-1",
    "severity": "low",
    "category": "code-quality",
    "title": "Unused Import",
    "description": "Imported module is never used",
    "location": {
      "file": "src/utils/helpers.ts",
      "line": 3,
      "column": 1
    },
    "codeSnippet": "// Unused imports:\nimport { someFunction } from './unused';  // Never used\nimport lodash from 'lodash';  // Never used\nimport { formatDate, parseDate } from './date-utils';\n\n// Only formatDate is used\nexport const format = (date) => formatDate(date);",
    "recommendation": "Remove unused imports",
    "suggestion": "Remove someFunction and lodash imports",
    "remediation": "// Clean imports:\nimport { formatDate } from './date-utils';\n\nexport const format = (date) => formatDate(date);",
    "rule": "unused-import",
    "message": "Imported module is never used"
  }
]