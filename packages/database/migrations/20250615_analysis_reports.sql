-- Migration: Create analysis_reports table for storing standardized reports
-- This table stores the complete analysis reports generated by the Reporter Agent
-- for UI consumption and historical tracking

-- Create enum for risk levels
CREATE TYPE risk_level AS ENUM ('low', 'medium', 'high', 'critical');

-- Create the analysis_reports table
CREATE TABLE IF NOT EXISTS analysis_reports (
  -- Primary identification
  id TEXT PRIMARY KEY, -- Generated report ID from Reporter Agent
  repository_url TEXT NOT NULL,
  pr_number INTEGER NOT NULL,
  
  -- User and organization tracking
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  
  -- Complete report data
  report_data JSONB NOT NULL, -- Full StandardReport structure
  
  -- Quick access fields from overview (for filtering/sorting)
  overview JSONB NOT NULL, -- Extracted overview section
  analysis_score INTEGER NOT NULL CHECK (analysis_score >= 0 AND analysis_score <= 100),
  risk_level risk_level NOT NULL,
  total_findings INTEGER NOT NULL DEFAULT 0,
  total_recommendations INTEGER NOT NULL DEFAULT 0,
  learning_path_available BOOLEAN NOT NULL DEFAULT false,
  estimated_remediation_time TEXT,
  
  -- Metadata
  analysis_mode TEXT NOT NULL,
  agents_used TEXT[] NOT NULL DEFAULT '{}',
  tools_executed TEXT[] NOT NULL DEFAULT '{}',
  processing_time INTEGER, -- milliseconds
  model_versions JSONB DEFAULT '{}',
  
  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Indexes for common queries
  CONSTRAINT unique_repo_pr_user UNIQUE (repository_url, pr_number, user_id)
);

-- Create indexes for performance
CREATE INDEX idx_analysis_reports_user_id ON analysis_reports(user_id);
CREATE INDEX idx_analysis_reports_org_id ON analysis_reports(organization_id);
CREATE INDEX idx_analysis_reports_repository ON analysis_reports(repository_url);
CREATE INDEX idx_analysis_reports_created_at ON analysis_reports(created_at DESC);
CREATE INDEX idx_analysis_reports_risk_level ON analysis_reports(risk_level);
CREATE INDEX idx_analysis_reports_score ON analysis_reports(analysis_score DESC);

-- Create GIN index for JSONB search
CREATE INDEX idx_analysis_reports_data ON analysis_reports USING GIN (report_data);
CREATE INDEX idx_analysis_reports_overview ON analysis_reports USING GIN (overview);

-- Enable Row Level Security
ALTER TABLE analysis_reports ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
-- Users can only see their own reports or reports from their organization
CREATE POLICY "Users can view own reports" ON analysis_reports
  FOR SELECT
  USING (
    auth.uid() = user_id OR 
    (organization_id IS NOT NULL AND 
     organization_id IN (
       SELECT organization_id 
       FROM organization_members 
       WHERE user_id = auth.uid()
     ))
  );

-- Users can create their own reports
CREATE POLICY "Users can create own reports" ON analysis_reports
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Users can update their own reports
CREATE POLICY "Users can update own reports" ON analysis_reports
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Users can delete their own reports
CREATE POLICY "Users can delete own reports" ON analysis_reports
  FOR DELETE
  USING (auth.uid() = user_id);

-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_analysis_reports_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for updated_at
CREATE TRIGGER analysis_reports_updated_at
  BEFORE UPDATE ON analysis_reports
  FOR EACH ROW
  EXECUTE FUNCTION update_analysis_reports_updated_at();

-- Create view for report summaries (for listing pages)
CREATE OR REPLACE VIEW analysis_report_summaries AS
SELECT 
  id,
  repository_url,
  pr_number,
  user_id,
  organization_id,
  overview->>'executiveSummary' as executive_summary,
  analysis_score,
  risk_level,
  total_findings,
  total_recommendations,
  learning_path_available,
  estimated_remediation_time,
  analysis_mode,
  array_length(agents_used, 1) as agent_count,
  array_length(tools_executed, 1) as tool_count,
  processing_time,
  created_at
FROM analysis_reports;

-- Grant permissions on the view
GRANT SELECT ON analysis_report_summaries TO authenticated;

-- Create function to get report by ID with proper access control
CREATE OR REPLACE FUNCTION get_analysis_report(report_id TEXT)
RETURNS analysis_reports AS $$
DECLARE
  report analysis_reports;
BEGIN
  SELECT * INTO report
  FROM analysis_reports
  WHERE id = report_id
    AND (
      user_id = auth.uid() OR
      (organization_id IS NOT NULL AND 
       organization_id IN (
         SELECT organization_id 
         FROM organization_members 
         WHERE user_id = auth.uid()
       ))
    );
  
  IF report.id IS NULL THEN
    RAISE EXCEPTION 'Report not found or access denied';
  END IF;
  
  RETURN report;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to get latest report for a repository/PR
CREATE OR REPLACE FUNCTION get_latest_analysis_report(
  p_repository_url TEXT,
  p_pr_number INTEGER
)
RETURNS analysis_reports AS $$
DECLARE
  report analysis_reports;
BEGIN
  SELECT * INTO report
  FROM analysis_reports
  WHERE repository_url = p_repository_url
    AND pr_number = p_pr_number
    AND (
      user_id = auth.uid() OR
      (organization_id IS NOT NULL AND 
       organization_id IN (
         SELECT organization_id 
         FROM organization_members 
         WHERE user_id = auth.uid()
       ))
    )
  ORDER BY created_at DESC
  LIMIT 1;
  
  RETURN report;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to get report statistics for a user
CREATE OR REPLACE FUNCTION get_user_report_statistics(p_user_id UUID DEFAULT NULL)
RETURNS TABLE (
  total_reports BIGINT,
  total_findings BIGINT,
  avg_score NUMERIC,
  risk_distribution JSONB,
  recent_activity JSONB
) AS $$
BEGIN
  RETURN QUERY
  WITH user_reports AS (
    SELECT * FROM analysis_reports
    WHERE user_id = COALESCE(p_user_id, auth.uid())
  ),
  risk_counts AS (
    SELECT 
      COUNT(*) FILTER (WHERE risk_level = 'critical') as critical,
      COUNT(*) FILTER (WHERE risk_level = 'high') as high,
      COUNT(*) FILTER (WHERE risk_level = 'medium') as medium,
      COUNT(*) FILTER (WHERE risk_level = 'low') as low
    FROM user_reports
  ),
  recent AS (
    SELECT 
      DATE(created_at) as report_date,
      COUNT(*) as report_count
    FROM user_reports
    WHERE created_at >= NOW() - INTERVAL '30 days'
    GROUP BY DATE(created_at)
    ORDER BY report_date DESC
  )
  SELECT 
    COUNT(*)::BIGINT as total_reports,
    SUM(total_findings)::BIGINT as total_findings,
    ROUND(AVG(analysis_score), 2) as avg_score,
    jsonb_build_object(
      'critical', rc.critical,
      'high', rc.high,
      'medium', rc.medium,
      'low', rc.low
    ) as risk_distribution,
    jsonb_agg(
      jsonb_build_object(
        'date', r.report_date,
        'count', r.report_count
      ) ORDER BY r.report_date DESC
    ) as recent_activity
  FROM user_reports
  CROSS JOIN risk_counts rc
  LEFT JOIN recent r ON true
  GROUP BY rc.critical, rc.high, rc.medium, rc.low;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add comments for documentation
COMMENT ON TABLE analysis_reports IS 'Stores standardized analysis reports generated by the Reporter Agent';
COMMENT ON COLUMN analysis_reports.report_data IS 'Complete StandardReport structure as JSONB';
COMMENT ON COLUMN analysis_reports.overview IS 'Extracted overview section for quick access';
COMMENT ON COLUMN analysis_reports.analysis_score IS 'Overall code quality score (0-100)';
COMMENT ON COLUMN analysis_reports.risk_level IS 'Calculated risk level based on findings';
COMMENT ON COLUMN analysis_reports.estimated_remediation_time IS 'Human-readable time estimate (e.g., "2 weeks")';
