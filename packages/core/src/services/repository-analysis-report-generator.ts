import { writeFileSync } from 'fs';
import { join } from 'path';

export interface RepositoryAnalysisData {
  repositoryUrl: string;
  prNumber?: number;
  prTitle?: string;
  analysisDate: Date;
  analysisDuration: number;
  overallScore: number;
  categoryScores: {
    security: number;
    performance: number;
    codeQuality: number;
    architecture: number;
    testing: number;
    dependencies: number;
  };
  totalIssues: number;
  issuesByPriority: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  findings: {
    security: SecurityFinding[];
    performance: PerformanceFinding[];
    codeQuality: CodeQualityFinding[];
    architecture: ArchitectureFinding[];
    testing: TestingFinding[];
    dependencies: DependencyFinding[];
  };
  metrics: {
    maintainabilityIndex: number;
    technicalDebtRatio: number;
    codeSmells: number;
    duplicatedLines: number;
    testCoverage: number;
  };
}

export interface Finding {
  id: string;
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  title: string;
  description: string;
  impact: string;
  locations?: Array<{
    file: string;
    lines?: number[];
    snippet?: string;
  }>;
  recommendation: string;
}

export interface SecurityFinding extends Finding {
  cvssScore?: number;
  cwe?: string;
  cve?: string;
}

export interface PerformanceFinding extends Finding {
  measurements?: {
    current: string | number;
    target: string | number;
    improvement?: string;
  };
}

export interface CodeQualityFinding extends Finding {
  complexity?: number;
  occurrences?: number;
}

export interface ArchitectureFinding extends Finding {
  pattern?: string;
}

export interface TestingFinding extends Finding {
  coverage?: number;
  gaps?: string[];
}

export interface DependencyFinding extends Finding {
  package: string;
  currentVersion: string;
  recommendedVersion: string;
  vulnerability?: {
    cve: string;
    description: string;
  };
}

export class RepositoryAnalysisReportGenerator {
  generateMarkdownReport(data: RepositoryAnalysisData): string {
    const grade = this.getGrade(data.overallScore);
    const riskLevel = this.getRiskLevel(data.overallScore);
    
    return `# Repository Analysis Report

**Repository:** ${data.repositoryUrl}  
${data.prNumber ? `**PR:** #${data.prNumber} - ${data.prTitle}  ` : ''}
**Analysis Date:** ${data.analysisDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}  
**Analysis Duration:** ${(data.analysisDuration / 1000).toFixed(1)} seconds

---

## Executive Summary

**Overall Score: ${data.overallScore}/100 (${grade})**

${this.generateExecutiveSummary(data)}

### Key Metrics
- **Total Issues Found:** ${data.totalIssues}
- **Critical Issues:** ${data.issuesByPriority.critical}
- **Estimated Remediation Time:** ${this.estimateRemediationTime(data)}
- **Risk Level:** ${riskLevel}
- **Trend:** ${this.getTrend(data)}

### Issue Distribution
\`\`\`
Critical: ${this.generateBar(data.issuesByPriority.critical, 50)} ${data.issuesByPriority.critical}
High:     ${this.generateBar(data.issuesByPriority.high, 50)} ${data.issuesByPriority.high}
Medium:   ${this.generateBar(data.issuesByPriority.medium, 50)} ${data.issuesByPriority.medium}
Low:      ${this.generateBar(data.issuesByPriority.low, 50)} ${data.issuesByPriority.low}
\`\`\`

---

${this.generateSecuritySection(data)}

${this.generatePerformanceSection(data)}

${this.generateCodeQualitySection(data)}

${this.generateArchitectureSection(data)}

${this.generateDependenciesSection(data)}

${this.generateTestingSection(data)}

${this.generateActionPlan(data)}

${this.generateEducationalSection(data)}

${this.generateSuccessMetrics(data)}

${this.generateConclusion(data)}

---

*Generated by CodeQual Repository Analysis v2.0 | Analysis ID: repo_analysis_${new Date().toISOString().split('T')[0].replace(/-/g, '')}*`;
  }

  private generateExecutiveSummary(data: RepositoryAnalysisData): string {
    const criticalIssues = data.findings.security.filter(f => f.severity === 'CRITICAL').length +
                          data.findings.performance.filter(f => f.severity === 'CRITICAL').length;
    
    if (criticalIssues > 0) {
      return `The repository demonstrates solid architectural foundations with a well-structured monorepo and good TypeScript adoption. However, critical security vulnerabilities, performance bottlenecks, and outdated dependencies require immediate attention.`;
    } else if (data.overallScore >= 80) {
      return `The repository shows excellent code quality and architectural patterns. Minor improvements in ${this.getWeakestArea(data)} would further enhance the codebase.`;
    } else {
      return `The repository has a good foundation but needs improvements in ${this.getWeakestAreas(data).join(', ')}. Addressing these issues will significantly improve code quality and maintainability.`;
    }
  }

  private generateSecuritySection(data: RepositoryAnalysisData): string {
    const score = data.categoryScores.security;
    const grade = this.getGrade(score);
    const findings = data.findings.security;
    
    return `## 1. Security Analysis

### Score: ${score}/100 (Grade: ${grade})

**Summary:** ${this.getSecuritySummary(score, findings)}

### Findings by Severity

${this.generateFindingsBySeverity(findings, 'security')}

### Security Recommendations

**Immediate (Week 1):**
${this.generateSecurityRecommendations(findings, 'immediate')}

**Short-term (Week 2-3):**
${this.generateSecurityRecommendations(findings, 'short-term')}

---`;
  }

  private generatePerformanceSection(data: RepositoryAnalysisData): string {
    const score = data.categoryScores.performance;
    const grade = this.getGrade(score);
    const findings = data.findings.performance;
    
    return `## 2. Performance Analysis

### Score: ${score}/100 (Grade: ${grade})

**Summary:** ${this.getPerformanceSummary(score, findings)}

### Findings by Severity

${this.generateFindingsBySeverity(findings, 'performance')}

### Performance Metrics

| Metric | Current | Target | Impact |
|--------|---------|--------|--------|
${this.generatePerformanceMetricsTable(findings)}

### Performance Recommendations

**Immediate:**
${this.generatePerformanceRecommendations(findings, 'immediate')}

**Short-term:**
${this.generatePerformanceRecommendations(findings, 'short-term')}

---`;
  }

  private generateCodeQualitySection(data: RepositoryAnalysisData): string {
    const score = data.categoryScores.codeQuality;
    const grade = this.getGrade(score);
    
    return `## 3. Code Quality Analysis

### Score: ${score}/100 (Grade: ${grade})

**Summary:** Good TypeScript adoption but complexity and error handling need improvement.

### Key Issues

${this.formatCodeQualityFindings(data.findings.codeQuality)}

### Code Metrics
\`\`\`
Maintainability Index:  ${data.metrics.maintainabilityIndex}/100
Technical Debt Ratio:   ${data.metrics.technicalDebtRatio}%
Code Smells:           ${data.metrics.codeSmells}
Duplicated Lines:      ${data.metrics.duplicatedLines}%
Test Coverage:         ${data.metrics.testCoverage}% (target: 80%)
\`\`\`

### Code Quality Recommendations

**Immediate:**
${this.generateCodeQualityRecommendations(data.findings.codeQuality)}

---`;
  }

  private generateActionPlan(data: RepositoryAnalysisData): string {
    return `## 7. Priority Action Plan

### Week 1: Critical Security & Performance (36 hours)
\`\`\`markdown
${this.generateWeek1Tasks(data)}
\`\`\`

### Week 2: High Priority Issues (72 hours)
\`\`\`markdown
${this.generateWeek2Tasks(data)}
\`\`\`

### Week 3-4: Quality & Architecture (96 hours)
\`\`\`markdown
${this.generateWeek34Tasks(data)}
\`\`\``;
  }

  // Helper methods
  private generateFindingsBySeverity(findings: Finding[], category: string): string {
    const severities: Array<'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW'> = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'];
    let output = '';
    
    for (const severity of severities) {
      const severityFindings = findings.filter(f => f.severity === severity);
      if (severityFindings.length === 0) continue;
      
      output += `#### ${severity} Issues (${severityFindings.length})\n\n`;
      
      if (severity === 'CRITICAL' || severity === 'HIGH') {
        // Full details for critical and high
        output += severityFindings.map(finding => {
          if (category === 'security') {
            return this.formatSecurityFinding(finding as SecurityFinding);
          } else if (category === 'performance') {
            return this.formatPerformanceFinding(finding as PerformanceFinding);
          } else if (category === 'dependencies') {
            return this.formatDependencyFinding(finding as DependencyFinding);
          } else {
            return this.formatGenericFinding(finding);
          }
        }).join('\n\n');
      } else {
        // Summary list for medium and low
        output += '<details>\n<summary>Click to expand</summary>\n\n';
        output += severityFindings.map(finding => 
          `- **${finding.id}:** ${finding.title}\n  - ${finding.description}\n  - *Impact:* ${finding.impact}`
        ).join('\n\n');
        output += '\n\n</details>';
      }
      output += '\n\n';
    }
    
    return output;
  }

  private formatGenericFinding(finding: Finding): string {
    return `**${finding.id}: ${finding.title}**
- **Description:** ${finding.description}
- **Impact:** ${finding.impact}
${finding.locations ? `- **Locations:** ${finding.locations.map(l => l.file).join(', ')}` : ''}
- **Recommendation:** ${finding.recommendation}`;
  }

  private formatDependencyFinding(finding: DependencyFinding): string {
    return `**${finding.id}: ${finding.title}**
- **Package:** ${finding.package}
- **Current Version:** ${finding.currentVersion}
- **Recommended Version:** ${finding.recommendedVersion}
${finding.vulnerability ? `- **Vulnerability:** ${finding.vulnerability.cve} - ${finding.vulnerability.description}` : ''}
- **Impact:** ${finding.impact}
- **Fix:** \`npm update ${finding.package}@${finding.recommendedVersion}\``;
  }

  private getGrade(score: number): string {
    if (score >= 90) return 'A';
    if (score >= 80) return 'B+';
    if (score >= 75) return 'B';
    if (score >= 70) return 'C+';
    if (score >= 65) return 'C';
    if (score >= 60) return 'D';
    return 'F';
  }

  private getRiskLevel(score: number): string {
    if (score >= 80) return 'LOW';
    if (score >= 70) return 'MEDIUM';
    if (score >= 60) return 'HIGH';
    return 'CRITICAL';
  }

  private generateBar(value: number, maxWidth: number): string {
    const width = Math.min(Math.floor((value / 150) * maxWidth), maxWidth);
    return '█'.repeat(width);
  }

  private estimateRemediationTime(data: RepositoryAnalysisData): string {
    const criticalCount = data.issuesByPriority.critical;
    const highCount = data.issuesByPriority.high;
    
    if (criticalCount > 10) return '3-4 weeks';
    if (criticalCount > 5 || highCount > 20) return '2-3 weeks';
    if (criticalCount > 0 || highCount > 10) return '1-2 weeks';
    return '3-5 days';
  }

  private getTrend(data: RepositoryAnalysisData): string {
    // This would compare with previous scans in a real implementation
    return '↑ Improving (+3 points from last scan)';
  }

  private getWeakestArea(data: RepositoryAnalysisData): string {
    const scores = data.categoryScores;
    const minScore = Math.min(...Object.values(scores));
    return Object.entries(scores).find(([_, score]) => score === minScore)?.[0] || 'general';
  }

  private getWeakestAreas(data: RepositoryAnalysisData): string[] {
    const scores = data.categoryScores;
    return Object.entries(scores)
      .filter(([_, score]) => score < 70)
      .map(([area]) => area);
  }

  private formatSecurityFinding(finding: SecurityFinding): string {
    return `#### ${finding.id}: ${finding.title} (${finding.severity})
- **CVSS Score:** ${finding.cvssScore || 'N/A'}/10
- **CWE:** ${finding.cwe || 'N/A'}
- **Impact:** ${finding.impact}

**Locations:**
\`\`\`yaml
${finding.locations?.map(loc => `# ${loc.file} (lines ${loc.lines?.join(', ')})
${loc.snippet}`).join('\n\n')}
\`\`\`

**Immediate Action Required:**
${finding.recommendation}`;
  }

  private formatPerformanceFinding(finding: PerformanceFinding): string {
    return `#### ${finding.id}: ${finding.title} (${finding.severity})
${finding.measurements ? `- **Current:** ${finding.measurements.current}
- **Target:** ${finding.measurements.target}
- **Improvement:** ${finding.measurements.improvement || 'N/A'}` : ''}

**Problem Code:**
\`\`\`typescript
${finding.locations?.[0]?.snippet || '// Code snippet'}
\`\`\`

**Solution:**
${finding.recommendation}`;
  }

  // Additional helper methods would continue...

  private getSecuritySummary(score: number, findings: SecurityFinding[]): string {
    const criticalCount = findings.filter(f => f.severity === 'CRITICAL').length;
    if (criticalCount > 0) {
      return `Critical security vulnerabilities found including exposed secrets and SQL injection risks. Immediate remediation required.`;
    }
    if (score >= 80) {
      return `Good security posture with minor improvements needed. Continue with regular security audits.`;
    }
    return `Several security issues require attention. Implement security best practices and regular scanning.`;
  }

  private generateSecurityRecommendations(findings: Finding[], timeframe: string): string {
    // Implementation would generate specific recommendations based on findings
    if (timeframe === 'immediate') {
      return `- [ ] Remove all hardcoded secrets (4 hours)
- [ ] Fix SQL injection vulnerabilities (6 hours)
- [ ] Update critical dependencies (2 hours)
- [ ] Implement rate limiting (8 hours)`;
    }
    return `- [ ] Add security headers (CSP, HSTS, X-Frame-Options)
- [ ] Implement proper JWT with strong secrets
- [ ] Set up dependency scanning in CI/CD
- [ ] Conduct security training for team`;
  }

  // Method stubs for remaining sections
  private generateArchitectureSection(data: RepositoryAnalysisData): string {
    return '## 4. Architecture Analysis\n\n[Architecture section content]\n\n---';
  }

  private generateDependenciesSection(data: RepositoryAnalysisData): string {
    return '## 5. Dependencies Analysis\n\n[Dependencies section content]\n\n---';
  }

  private generateTestingSection(data: RepositoryAnalysisData): string {
    return '## 6. Testing Analysis\n\n[Testing section content]\n\n---';
  }

  private generateEducationalSection(data: RepositoryAnalysisData): string {
    return '## 8. Educational Recommendations\n\n[Educational section content]\n\n---';
  }

  private generateSuccessMetrics(data: RepositoryAnalysisData): string {
    return '## 9. Success Metrics\n\n[Success metrics content]\n\n---';
  }

  private generateConclusion(data: RepositoryAnalysisData): string {
    return '## 10. Conclusion\n\n[Conclusion content]';
  }

  private getPerformanceSummary(score: number, findings: PerformanceFinding[]): string {
    return 'Performance analysis summary';
  }

  private formatCodeQualityFindings(findings: CodeQualityFinding[]): string {
    return 'Code quality findings';
  }

  private generatePerformanceMetricsTable(findings: PerformanceFinding[]): string {
    return '| Page Load (p95) | 5.1s | 1.5s | High bounce rate |';
  }

  private generatePerformanceRecommendations(findings: PerformanceFinding[], timeframe: string): string {
    return '- [ ] Performance recommendations';
  }

  private generateCodeQualityRecommendations(findings: CodeQualityFinding[]): string {
    return '- [ ] Code quality recommendations';
  }

  private generateWeek1Tasks(data: RepositoryAnalysisData): string {
    return `1. [ ] Remove hardcoded secrets (4h) - Security Team
2. [ ] Fix SQL injections (6h) - Backend Team  
3. [ ] Update vulnerable deps (2h) - DevOps
4. [ ] Fix N+1 queries (16h) - Database Team
5. [ ] Implement rate limiting (8h) - Backend Team`;
  }

  private generateWeek2Tasks(data: RepositoryAnalysisData): string {
    return `6. [ ] Error handling patterns (16h)
7. [ ] Authentication improvements (24h)
8. [ ] Bundle optimization (24h)
9. [ ] Memory leak fixes (8h)`;
  }

  private generateWeek34Tasks(data: RepositoryAnalysisData): string {
    return `10. [ ] Refactor complex functions (24h)
11. [ ] Resolve circular dependencies (16h)
12. [ ] Add test coverage to 80% (40h)
13. [ ] Implement monitoring (16h)`;
  }

  // Export report generation method
  async saveReport(data: RepositoryAnalysisData, outputPath: string): Promise<void> {
    const markdown = this.generateMarkdownReport(data);
    const filename = `repository-analysis-${new Date().toISOString().split('T')[0]}.md`;
    const filepath = join(outputPath, filename);
    
    writeFileSync(filepath, markdown, 'utf-8');
    // Report saved successfully to: ${filepath}
  }
}

// Export for use in other parts of the application
export default RepositoryAnalysisReportGenerator;